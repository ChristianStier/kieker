\documentclass[a4paper, oneside, 11pt]{scrartcl}

% Get the necessary Packages
\input{Packages}
% Only some new commands.
\input{Macros}

% Set title and everything.
\title{Tutorial for \Kieker:\\ Monitoring and Analysis of Software Behavior}

% Here we go.
\begin{document}
\maketitle
\tableofcontents

\newpage

\section{Overview}
\subsection{What is \Kieker?}
\Kieker\ is a framework\footnote{A framework is sort of a library which provides specific and extended functionality} which allows programmers and software engineers the monitoring and analysis of program flows and the runtime behavior of java applications. Normal (``plain'') java applications can be arranged with the framework as well as server based java web applications. The framework itself aims to provide an easy managable and maintanable piece of software, which can be included uncomplicated into existing software projects. While \Kieker\ analyzes the own sourcecode reliably, it causes itself only very less overhead during monitoring.\\
\Kieker\ can be used to put whole method calls on a watch, but single statements (e.g. a = a + 1) as well.
\begin{figure}[H]
  \begin{center}
    \includegraphics[width=1.0\textwidth]{kiekerComponentDiagram.pdf}
    \label{image:componentdiagram}
    \caption{\Kieker\ component diagram}
  \end{center}
\end{figure}
As can be seen in figure \ref{image:componentdiagram}, the framework consists mainly of two big parts:
\begin{itemize}
  \item \textbf{\KiekerMonitoring}\\
    This is the part which is responsible for the logging and the recording of the program behavior. The result of this component are the recorded informations which can then be written into different output streams, like for example into files or into a database.
  \item \textbf{\KiekerAnalysis}\\
    This part is responsible for the evaluation and visualization of the recorded information. It uses the files (or general any collected data which is available as monitoring records) for the analysis and to produce graphs (e.g. Component-Dependency-Graph).
\end{itemize}

\subsection{What ist the purpose of this tutorial?}
In this tutorial, we will take a closer look at both, the \textbf{\KiekerMonitoring}- and the \textbf{\KiekerAnalysis}-part. That means, we will describe on the one hand how \KiekerMonitoring\ can be used to mark parts of the own sourcecode for \Kieker\ and to let them execute under surveilance, so that the recorded information can be saved in files. On the other hand we will use \KiekerAnalysis\ to visualize our recorded data.\\
We will show how to create and execute a simple example before we go deeper into the parts of the framework.


\section{Quickstart}

\subsection{Downloading and installing \Kieker}
For the monitoring and analysis of the source code, it is necessary to download the \Kieker\ binaries from \KiekerDownloadUrl\ first. Once that is done, the content of the zip- respectively the tar.gz-file should be extracted to any directory, for example ``$\sim$/kieker'' (under Linux) or ``c:$\backslash$program files$\backslash$kieker'' (under Windows).\\
That is already enough for the ``installation'' of \Kieker.

\subsection{Monitoring}
Now for the creation of a simple example for the use of the \Kieker\ framework (note: The example is available on the website of \Kieker). It is recommended to create a new working directory (e.g. $\sim$/example) with the following subdirectories:
\begin{itemize}
  \item src (For the sourcecode files)
  \item lib (For the libraries and needed jar-files)
  \item META-INF (For the configuration files of \Kieker)
  \item build (For the builded class files of Java)
\end{itemize}
Before we start with the sourcedoe, we need to copy some files from the \Kieker\ directory to our own working directory\footnote{It would be possible to access the required files within the \Kieker\ directory, but the copying will make the compiling much more comfortable.}.
\begin{itemize}
  \item $\sim$/kieker/dist/kieker-tpmon-\version\_ctrl.jar to $\sim$/example/lib/kieker-tpmon-\version\_ctrl.jar
  \item $\sim$/kieker/dist/kieker-common-\version.jar to $\sim$/example/lib/kieker-common-\version.jar
  \item $\sim$/kieker/lib/commons-logging-1.1.1.jar to $\sim$/example/lib/commons-logging-1.1.1.jar
  \item $\sim$/kieker/META-INF/tpmon.properties.example to $\sim$/META-INF/\textbf{tpmon.properties}
  \item $\sim$/kieker/META-INF/log4j.properties.example to $\sim$/META-INF/\textbf{log4j.properties}
\end{itemize}
The last two files are configuration files, but for a quick start they are already configurated correctly.\\

We start with creating two directories for our packages:
\begin{itemize}
  \item $\sim$/example/src/mySimpleKiekerExample
  \item $\sim$/example/src/mySimpleKiekerExample/bookstoreTracing
\end{itemize}
In the last directory, we create three files: 
\begin{itemize}
  \item CRM.java
  \item Catalog.java
  \item Bookstore.java
\end{itemize}
The file ``Bookstore.java'' should contain of the lines showed in listing \ref{listing:Bookstore.java}.

\setJavaCodeListing

\lstset{caption=Bookstore.java, label=listing:Bookstore.java}
\lstinputlisting{source-example/manual-monitoring/src/Bookstore.java}
Listing \ref{listing:Catalog.java} shows the content of ``Catalog.java'' and listing \ref{listing:CRM.java} the content of ``CRM.java''.
\lstset{caption=Catalog.java, label=listing:Catalog.java}
\lstinputlisting{source-example/manual-monitoring/src/Catalog.java}
\lstset{caption=CRM.java, label=listing:CRM.java}
\lstinputlisting{source-example/manual-monitoring/src/CRM.java}

The monitoring itself is done manually. Although this is not the strength of \Kieker\ it is pretty good for a quick start.
\lstset{caption=Cutting from Bookstore.java, label=listing:cuttingBookstore}
\begin{lstlisting}
long tin = TpmonController.getInstance().getTime();
Bookstore.searchBook();
long tout = TpmonController.getInstance().getTime();

KiekerExecutionRecord e = KiekerExecutionRecord.getInstance("mySimpleKiekerExample.bookstoreTracing.Bookstore", "searchBook()", "sessionID", 0, tin, tout, "vnName", 0, 0);
TpmonController.getInstance().logMonitoringRecord(e);
\end{lstlisting}
In listing \ref{listing:cuttingBookstore} can be seen, how the monitoring itself is done. We use the \textit{TpmonController} to get the current time in nano seconds and remember the time before and after a specific method call (in this case: \textit{searchBook()})\footnote{The code between the timekeeping does not need to be a method call of course. It can be ``plain'' code or more than one method call as well.}. These informations are stored in the so called execution record. It gets:
\begin{itemize}
 \item The component (the class) in which the called method is.
 \item The called method.
 \item The session id. In this case we can use any string.
 \item The trace id of the current trace we want to record. Due to the fact, that we follow only one trace, this is zero in all recordings.
 \item The time before the sourcecode which should be measured.
 \item The time after the sourcecode which should be measured.
 \item The name of the current host. This is not very important in this case, because we have only one host. The name can be choosen freely.
 \item The eoi (execution order index). This tells \Kieker\ later the sequence of the different calls. It should be of course unique within a trace.
 \item The ess (execution stack size). This number tells \Kieker\ that the execution was started when the calling stack of the corresponding trace was just the ess.
\end{itemize}
For the moment we have to choose the eoi and ess manually. These numbers can be choosen later automaticaly by \Kieker\ of course.\\
Once this is done, we should be able to compile and execute the sourcecode:
\setBashListing
\begin{lstlisting}
nils@Laptop:~/example$ javac ./src/Bookstore.java ./src/Catalog.java ./src/CRM.java -classpath ./lib/kieker-tpmon-1.1_ctrl.jar -d ./build
nils@Laptop:~/example$ java -Dlog4j.configuration=META-INF/log4j.properties -classpath ./build/:./lib/kieker-tpmon-1.1_ctrl.jar:./lib/kieker-common-1.1.jar:./lib/commons-logging-1.1.1.jar mySimpleKiekerExample.bookstoreTracing.Bookstore
\end{lstlisting}
If everything worked correctly, there should now be a new directory named ``tpmon-20100605-115948636-UTC'' (just with other numbers) in the default temporary directory (under Linux this should be ``/tmp''). In this directory, there should be a file with the extension ``.dat'' with a content similar to the following:
\begin{lstlisting}
$1;1275745883934593403;-1;mySimpleKiekerExample.bookstoreTracing.Catalog.getBook(false);sessionID;0;1275745883931011663;1275745883933424540;vnName;1;1
$1;1275745883937096236;-1;mySimpleKiekerExample.bookstoreTracing.Catalog.getBook(false);sessionID;0;1275745883935003302;1275745883937075214;vnName;3;2
$1;1275745883937119354;-1;mySimpleKiekerExample.bookstoreTracing.CRM.getOffers();sessionID;0;1275745883934661568;1275745883937111043;vnName;2;1
$1;1275745883937128922;-1;mySimpleKiekerExample.bookstoreTracing.Bookstore.searchBook();sessionID;0;1275745883931007961;1275745883937123824;vnName;0;0 
\end{lstlisting}
These are the recorded informations from our sourcecode. This data can now be visualized with the help of \Kieker.

\subsection{Analysis}
Assume that we already have our recorded informations saved in a ``.dat''-file somewhere for example the in ``tmp``-directory, we can now start with converting these informations into graphs. For the first, we change into our \Kieker\-directory ($\sim$/kieker). It is necessary to create a new directory for the graphs first:
\begin{lstlisting}
nils@Laptop:~/kieker$ mkdir /tmp/graphs
\end{lstlisting}
The shell-script ''./bin/trace-analysis.sh`` will now do most of the job.
\begin{lstlisting}
nils@Laptop:~/kieker$ ./bin/trace-analysis.sh --plot-Sequence-Diagrams --short-labels -i /tmp/tpmon-20100606-112536844-UTC/ -o /tmp/graphs/
\end{lstlisting}
The command ''--plot-Sequence-Diagrams`` tells the shell script to convert our data into a sequence diagram (other diagrams and graphs can be plot of course as well); with ''--short-labels`` we make sure that the components get a shorter name and the directories after ''-i`` and ''-o`` are the input- and the output-directories. If everything went well, \Kieker\ converted the data into files, which can now converted directly into visual graphs:
\begin{lstlisting}
nils@Laptop:~/kieker$ ./bin/dotPic-fileConverter.sh /tmp/graphs/ svg
\end{lstlisting}
The shell script ''./bin/dotPic-fileConverter.sh`` gets the directory with the files and the desired file extension (e.g. svg or png). The resulting graphs should now be available in ''/tmp/graphs`` and should look like the following:
\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{sequenceDiagram.pdf}
    \label{image:sequencediagram}
    \caption{The resulting sequence diagram}
  \end{center}
\end{figure}
We are now able to monitor sourcecode in a simple way and to visualize these recorded informations.

\subsection{Using annotations}
Now we want to monitor whole methods without surrounding the method calls with a block where we keep the time manually. We will now use so called annotations to mark the methods we want to monitor. As can be seen in the following listing we write the annotation \textit{kieker.tpmon.annotation.TpmonExecutionMonitoringProbe} above the methods to be monitored. 
\setJavaCodeListing
\lstset{caption=Bookstore.java, label=listing:Bookstore2.java}
\lstinputlisting{source-example/annotation-monitoring/src/Bookstore.java}
To make sure that the sourcecode is monitored, we need now aspectJ. Therefore we copy the file ''META-INF/aop.xml.example`` from our \Kieker\ directory to our working directory to ''META-INF/aop.xml``. In this file it is written which parts of the sourcecode will be monitored.  And we need another libarary as well. We copy $\sim$/kieker/dist/kieker-tpmon-\version\_ctw.jar to $\sim$/example/lib/kieker-tpmon-\version\_ctw.jar\\
To make sure that every method in our program which is annotated will be monitored, we have to write the following into the file:
\setXMLListing 
\begin{lstlisting}
<aspectj>
	<!-- turn verbose on to check which files are instrumented -->
	<!-- <weaver options="-verbose"/> -->
	<weaver options="">
	
	<!-- The following line is the important one -->
	<include within="*"/> 

	<!-- uncomment following to instrument sun jpetstore -->
\end{lstlisting}
The compiling is pretty much the same as before, but in order to run the program, we have to copy the configuration files into the build-directory.
\begin{lstlisting}
nils@Laptop:~/example$ javac ./src/Bookstore.java ./src/Catalog.java ./src/CRM.java -classpath ./lib/kieker-tpmon-1.1_ctrl.jar -d ./build
nils@Laptop:~/example$ cp -r ./META-INF/ ./build/META-INF
nils@Laptop:~/example$ java -Dlog4j.configuration=META-INF/log4j.properties -Dtpmon.configuration=META-INF/tpmon.properties -javaagent:lib/aspectjweaver-1.6.6.jar -Dorg.aspectj.weaver.showWeaveInfo=true -Daj.weaving.verbose=true -classpath ./build/:./lib/kieker-tpmon-1.1_ctrl.jar:./lib/kieker-common-1.1.jar:./lib/commons-logging-1.1.1.jar mySimpleKiekerExample.bookstoreTracing.Bookstore
\end{lstlisting}


\section{\KiekerMonitoring}
\subsection{Configuration}
The configuration possibilties of \KiekerMonitoring can be done in the configuration file named ''\monitoringPropertiesFile``. It is possible to activate/deactivate the monitoring and the debugging, set the target of the recorded informations or the path for the temporary paths of \Kieker. Most of the variables are self-explanatory.  
\subsection{Probes}
The probes (figure \ref{image:componentdiagram} shows them as well) decide which (and where) information should be recorded. To create own probes can for example be necessary if we want to record only specific data, or only every second method call and so on.
\subsection{Writers}
\hypertarget{monitoringlogwriters}
The so called \textit{monitoring log writers} (they can be seen as well in figure \ref{image:componentdiagram}) are the parts of \Kieker\ which are responsible for writing and serializing the recorded informations into files, databases and so on. In other words: They get an instance of \textit{AbstractKiekerMonitoringRecord} and produce an output of any nature whatsoever.\\
As can be seen in figure \ref{image:writers} there are already some writers implemented.
\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.5\textwidth]{kieker_writerimpls.pdf}
		\label{image:writers}
		\caption{The inheritance hierarchy of the current implemented monitoring log writers}
	\end{center}
\end{figure}
As the quick start part already showed it, every monitored record is sent to the \textit{TpmonController} which itself calls the current writer. The writer uses for example the \textit{toArray()} method of the record to get the informations stored by the record as handable array. The writer is then able to write these objects for example into a file. The used writer can be changed in the configuration file of \KiekerMonitoring.\\
To implement an own writer class, the following steps has to be performed:
\begin{enumerate}
 \item The new writer has to implement \textit{kieker.tpmon.writer.IMonitoringLogWriter}.
 \item All methods from the interfaces \textit{kieker.tpmon.writer.IMonitoringLogWriter} and \textit{kieker.common.record.IMonitoringRecordReceiver} has to be implemented.
 \item The entry \textit{monitoringDataWriter} has to be changed in the configuration file ''tpmon.properties`` to the entire classname.
\end{enumerate}
The following example writer takes the informations from the given record and shows them just on the screen.
\setJavaCodeListing
\lstset{caption=OwnWriter.java, label=listing:OwnWriter.java}
\lstinputlisting{source-example/manual-monitoring-with-own-writer/src/OwnWriter.java}

\section{\KiekerAnalysis}
\subsection{Configuration}
The configuration of \KiekerAnalysis is possible in the file ''\analysisPropertiesFile``.
\subsection{Readers}
\begin{figure}[H]
	\begin{center}
		\includegraphics[width=0.5\textwidth]{kieker_readerimpls.pdf}
		\label{image:readers}
		\caption{}
	\end{center}
\end{figure}
The \textit{monitoring log readers} (their position can be found in figure \ref{image:componentdiagram}) are the counterpart to the \hyperlink{monitoringlogwriters}{\textit{monitoring log writers}}. While the writers get a record and write them in files or somewhere else, the readers take the writen data (from files, databases and so on) and convert them into an \textit{AbstractKiekerMonitoringRecord}. That means, that whenever we are implementing a new writer, we should also implement a corresponding reader. If we want for example save our recorded informations in a database, we have to be capable of reading these stored informations from the database again. The implementing of an own reader is nearly the same as the implementing of the writer.
\begin{enumerate}
 \item The new reader has to extend \textit{kieker.common.logReader.AbstractKiekerMonitoringLogReader}.
 \item All methods from the interface  \textit{kieker.common.logReader.IKiekerMonitoringLogReader} which has not been implemented yet by the class must be implemented.
\end{enumerate}

\subsection{Consumers}
The consumer is the part of \Kieker\ which decides what to do with the stored informations. 
\section{Appendix}
\subsection{Example logs}
\subsection{Shortcut via ant}
\subsection{Libraries}
\input{Libraries}
\subsection{Troubleshooting}
\end{document}
 
