apply plugin: 'java'

subprojects {
    apply plugin: 'java'
	
    version = kiekerVersion
	
	sourceCompatibility = 1.6
	targetCompatibility = 1.6
	
	sourceSets {
		main { 
			java { 
				srcDir 'src' 
				srcDir 'src-gen' 
			} 
			resources {
				srcDir 'src-resources'
			}
		}
		test {
			java {
				srcDir 'test-gen' 
				srcDir 'test' 
			} 
			resources {
				srcDir 'test-resources'
			}
		}
	}
	
	test {
		ignoreFailures = true
	}
	
	apply plugin: 'pmd'
	pmd { 
		ignoreFailures = true

		// Clear the rule set first. Otherwise we would have a lot of additional rules in our rule set.
		ruleSets = []
		ruleSetFiles = files(resolveRelativeToParent(dirConfig, 'pmdrules.xml'))
	}
	
	apply plugin: 'checkstyle'
	checkstyle {
		ignoreFailures = true
		showViolations = false

		configFile = resolveRelativeToParent(dirConfig, 'cs-conf.xml')
	}
	
	apply plugin: 'findbugs'
	findbugs { 
		ignoreFailures = true 
		effort = "max"
		reportLevel = "low"
		
		excludeFilter = resolveRelativeToParent(dirConfig, 'fb-filter.xml')
	}
	
	// CS is a little bit weird, when it comes to dependencies. 
	checkstyleTest.classpath += sourceSets.main.runtimeClasspath
	checkstyleMain.classpath += configurations.compile
	// This part makes sure that CS does not check the classes inside src-gen
	checkstyleMain.source = 'src'
	
	// Those are some dependencies which are needed by all submodules
	dependencies {
		pmd resolveLibrary('**/pmd-*/**/*.jar')
		checkstyle resolveLibrary('**/checkstyle-*/**/*.jar')
		findbugs resolveLibrary('**/findbugs-*/**/*.jar')
		
		testCompile resolveLibrary('junit-*.jar')
		testCompile resolveLibrary('hamcrest-core-*.jar')
	}
}

def resolveRelativeToParent(String directory, String file) {
	return rootProject.file(directory + '/' + file)
}

def resolveLibrary(String library) {
	def libraryDir = rootProject.file(dirLib)
	return fileTree(dir: libraryDir, include: library)
}

def today() {
    def date = new Date()
    def formattedDate = date.format('yyyy-MM-dd')
    return formattedDate
}

// We have multiple subprojects -but we do not want all of them in our JAR files.
def mainSubprojects = [project(':kieker-common'), project(':kieker-monitoring'), project(':kieker-analysis'), project(':kieker-tools')]

task mainJar(type: Jar, dependsOn:  mainSubprojects.tasks["build"] ) {
	baseName = kiekerPackagenamebase + "-" + kiekerVersion
    mainSubprojects.each { subproject ->
        from subproject.configurations.archives.allArtifacts.files.collect {
            zipTree(it)
        }
    }
	
	manifest {
		attributes (
			"Specification-Version": kiekerVersion,
			"Specification-Vendor": kiekerCopyright,
			"Implementation-Title": kiekerName,
			"Implementation-Version": kiekerVersion + " (" + today() + ")",
			"Implementation-Vendor": kiekerCopyright,
			"kieker" // The section name
		)
    }
}

task emfJar(type: Jar, dependsOn:  mainSubprojects.tasks["build"] ) {
	baseName = kiekerPackagenamebase + "-" + kiekerVersion + "_emf"
    mainSubprojects.each { subproject ->
        from subproject.configurations.archives.allArtifacts.files.collect {
            zipTree(it)
        }
    }
	from fileTree(dir: 'lib', include: '*emf*.jar').collect {
		zipTree(it)
	}
}

task aspectJJar(type: Jar, dependsOn:  mainSubprojects.tasks["build"] ) {
	baseName = kiekerPackagenamebase + "-" + kiekerVersion + "_aspectj"
    mainSubprojects.each { subproject ->
        from subproject.configurations.archives.allArtifacts.files.collect {
            zipTree(it)
        }
    }
	from fileTree(dir: 'lib', include: 'aspectjweaver-*.jar').collect {
		zipTree(it)
	}
}

task distribute(group: 'distribution', description: 'Distributes binary and source archives.', dependsOn: [':distributeBinaryZip', ':distributeSourceZip',':distributeBinaryTar', ':distributeSourceTar'])

def binaryContent = project.copySpec {
	from (projectDir) {
		include 'LICENSE'
		include 'HISTORY'
		include 'README'
		
		include 'bin/**'
		include 'lib/**'
		include 'javadoc/**'
		include 'build/libs/**'
	}
}

task docs(type: Javadoc) {
    source subprojects.collect {project -> project.sourceSets.main.allJava } 
    classpath = files(subprojects.collect {project -> project.sourceSets.main.compileClasspath}) 
    destinationDir = new File(projectDir, 'javadoc')
}

task distributeBinaryZip(type: Zip, group: 'distribution', description: 'Distributes binary archive.', dependsOn: [mainJar, emfJar, aspectJJar, docs]) {
	classifier = 'bin'
	with binaryContent
}

task distributeBinaryTar(type: Tar, group: 'distribution', description: 'Distributes binary archive.', dependsOn: [mainJar, emfJar, aspectJJar, docs]) {
	classifier = 'bin'
	with binaryContent
}

def sourceContent = project.copySpec {
	from (projectDir) {
		include '*'
		include 'bin/**'
		include 'src/**'
		include 'lib/**'
	}
}

task distributeSourceZip(type: Zip, group: 'distribution', description: 'Distributes source archive.', dependsOn: [mainJar, emfJar, aspectJJar]) {
	classifier = 'src'
	with sourceContent
}

task distributeSourceTar(type: Tar, group: 'distribution', description: 'Distributes source archive.', dependsOn: [mainJar, emfJar, aspectJJar]) {
	classifier = 'src'
	with sourceContent
}

task jenkinsBuild(dependsOn: [mainJar, emfJar, aspectJJar]) {
}

task jenkinsNightlyBuild(dependsOn: [distribute]) {
}