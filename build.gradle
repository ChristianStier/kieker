buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'de.aaschmid.gradle.plugins:gradle-cpd-plugin:0.1'
    }
}

allprojects {
    apply plugin: 'java'
	
    version = kiekerVersion
	
	sourceCompatibility = 1.6
	targetCompatibility = 1.6
	
	sourceSets {
		main { 
			java { 
				srcDir 'src' 
				srcDir 'src-gen' 
			} 
			resources {
				srcDir 'src-resources'
			}
		}
		test {
			java {
				srcDir 'test-gen' 
				srcDir 'test' 
			} 
			resources {
				srcDir 'test-resources'
			}
		}
		integrationTest {
			java {
				srcDir 'test-integration' 
				
				compileClasspath += main.output + test.output
				runtimeClasspath += main.output + test.output
			}
		}
	}
	
	configurations {
		integrationTestCompile.extendsFrom testCompile
		integrationTestRuntime.extendsFrom testRuntime
	}
	
	/*
	 * This task should only be executed when updating to a 
	 * newer Gradle version. Note that manual changes to the 
	 * previous scripts will need to be merged to the new 
	 * wrapper script manually. Note that this tasks also 
	 * creates/updates the wrapper scripts in subdirectories.
	 * */  
	task wrapper(type: Wrapper) {
		description = 'Downloads the Gradle wrapper scripts.'
		gradleVersion = '2.2.1'
	}
	
	task integrationTest(type: Test){
		testClassesDir = project.sourceSets.integrationTest.output.classesDir
		classpath = project.sourceSets.integrationTest.runtimeClasspath
	}
	check.dependsOn integrationTest
	
	test {
		ignoreFailures = true
	}
	
	apply plugin: 'cpd'
	tasks.cpd {
		reports {
			xml.enabled = true
			xml.destination = file("${buildDir}/reports/cpd/cpd.xml")
		}
		source = 'src'
	}

	apply plugin: 'pmd'
	pmd { 
		ignoreFailures = true

		// Clear the rule set first. Otherwise we would have a lot of additional rules in our rule set.
		ruleSets = []
		ruleSetFiles = files(resolveRelativeToParent(dirConfig, 'pmdrules.xml'))
	}
	
	apply plugin: 'checkstyle'
	checkstyle {
		ignoreFailures = true
		showViolations = false

		configFile = resolveRelativeToParent(dirConfig, 'cs-conf.xml')
	}
	
	apply plugin: 'findbugs'
	findbugs { 
		ignoreFailures = true 
		effort = "max"
		reportLevel = "low"
		
		excludeFilter = resolveRelativeToParent(dirConfig, 'fb-filter.xml')
	}

	// CS is a little bit weird, when it comes to dependencies. 
	checkstyleTest.classpath += sourceSets.main.runtimeClasspath
	checkstyleMain.classpath += configurations.compile
	// This part makes sure that CS does not check the classes inside src-gen
	checkstyleMain.source = 'src'
	
	// Those are some dependencies which are needed by all submodules
	dependencies {
		pmd resolveLibrary('**/pmd-*/**/*.jar')
		cpd resolveLibrary('**/pmd-*/**/*.jar')
		checkstyle resolveLibrary('**/checkstyle-*/**/*.jar')
		checkstyle project(':kieker-checkstyle-extension')
		findbugs resolveLibrary('**/findbugs-*/lib/*.jar')
		
		testCompile resolveLibrary('junit-*.jar')
		testCompile resolveLibrary('hamcrest-core-*.jar')
	}
}

def resolveRelativeToParent(String directory, String file) {
	return rootProject.file(directory + '/' + file)
}

def resolveLibrary(String library) {
	def libraryDir = rootProject.file(dirLib)
	return fileTree(dir: libraryDir, include: library)
}

def today() {
    def date = new Date()
    def formattedDate = date.format('yyyy-MM-dd')
    return formattedDate
}

def year() {
   def date = new Date()
   def formattedDate = date.format('yyyy')
   return formattedDate
}

// We have multiple subprojects - but we do not want all of them in our JAR files.
def mainSubprojects = [project(':kieker-common'), project(':kieker-monitoring'), project(':kieker-analysis'), project(':kieker-tools')]

task apidoc(type: Javadoc) {
    description = 'Generate the Javadoc API documentation for the Kieker Framework'

    source mainSubprojects.collect {project -> project.sourceSets.main.allJava } 
    classpath = files(mainSubprojects.collect {project -> project.sourceSets.main.compileClasspath}) 
    destinationDir = new File(projectDir, 'docs')
	
	title = "Kieker Monitoring and Analysis Framework, Vers. $kiekerVersion<br/>API Documentation"
	options.header = "Kieker $kiekerVersion"
	options.footer = "Kieker $kiekerVersion"
	options.bottom = "Copyright " + year() + " $kiekerCopyright, <a href=\"http://kieker-monitoring.net\">http://kieker-monitoring.net</a>"
	options.author = "true"
	options.version = "false"
	options.use = "true"
	options.tags = ["generated", "ordered", "model"]
}

ext.sharedManifest = manifest {
	attributes (
		"Specification-Title": kiekerName,
		"Specification-Version": kiekerVersion,
		"Specification-Vendor": kiekerCopyright,
		"Implementation-Title": kiekerName,
		"Implementation-Version": kiekerVersion + " (" + today() + ")",
		"Implementation-Vendor": kiekerCopyright,
		"kieker" // The section name
	)
}

def allArtifacts = {
	mainSubprojects.each { subproject ->
		from subproject.configurations.archives.allArtifacts.files.collect {
			zipTree(it)
		}
	}
}

def licence = {
	from file('LICENSE')
}

def aopxml = {
	from (file('kieker-examples/aop.example.xml')) {
		into 'META-INF'
	}
}

task mainJar(type: Jar, dependsOn:  mainSubprojects.tasks["build"] ) {
	baseName = kiekerPackagenamebase + "-" + kiekerVersion
	destinationDir = file('dist')
	version = ''
	configure allArtifacts
	configure licence
	configure aopxml
	
	manifest = project.manifest {
		from sharedManifest
	}
}

task emfJar(type: Jar, dependsOn:  mainSubprojects.tasks["build"] ) {
	baseName = kiekerPackagenamebase + "-" + kiekerVersion + "_emf"
	destinationDir = file('dist')
	version = ''
	configure allArtifacts
	configure licence
	configure aopxml
	
	from('lib') {
		include "org.eclipse.emf.common_${libEmfVersion}.LICENSE"
		include "org.eclipse.emf.ecore_${libEmfVersion}.LICENSE"
		include "org.eclipse.emf.ecore.xmi_${libEmfVersion}.LICENSE"
	}

	def emfJarsTree = fileTree(dir: 'lib', include: '*emf*.jar').collect {
		zipTree(it)
	}
	from(emfJarsTree) {
		exclude "META-INF/*.RSA"
        exclude "META-INF/*.SF"
		exclude "META-INF/eclipse.inf"
        exclude "META-INF/*.DSA"
        exclude "plugin.*"
		exclude "about.*"
		exclude "modeling32.png"
    }
	
	manifest = project.manifest {
		from sharedManifest
	}
}

task aspectJJar(type: Jar, dependsOn:  mainSubprojects.tasks["build"] ) {
	baseName = kiekerPackagenamebase + "-" + kiekerVersion + "_aspectj"
	destinationDir = file('dist')
	version = ''
	configure allArtifacts
	configure licence
	configure aopxml
	
	from fileTree(dir: 'lib', include: 'aspectjweaver-*.jar').collect {
		zipTree(it)
	}
	
	from file("lib/aspectjweaver-${libAspectjVersion}.LICENSE")
	
	manifest = project.manifest {
		from sharedManifest
		attributes (
			"Can-Redefine-Classes": 'true',
			"Premain-Class": 'kieker.monitoring.probe.aspectj.AspectJLoader'
		)
		attributes (
			"Specification-Title": "AspectJ Weaver Classes",
			"Specification-Version": libAspectjVersion,
			"Specification-Vendor": "aspectj.org",
			"Implementation-Title": "org.aspectj.weaver",
			"Implementation-Version": libAspectjVersion,
			"Implementation-Vendor": "aspectj.org",
			"Can-Redefine-Classes": "true",
			"Premain-Class": "org.aspectj.weaver.loadtime.Agent",
			"org/aspectj/weaver/" // The section name
		)
    }
}

task distribute(group: 'distribution', description: 'Distributes binary and source archives.', 
		dependsOn: [':distributeBinaryZip', ':distributeSourceZip',':distributeBinaryTar', ':distributeSourceTar'])

def binaryContent = project.copySpec {
	from (projectDir) {
		include 'LICENSE'
		include 'HISTORY'
		include 'README'
		
		include 'bin/**'
		include 'lib/**'
		include 'javadoc/**'
		include 'dist/*'
    
    exclude '**/.gradle/**'
	}
	from ('kieker-documentation') {
		include 'README-bin'
		rename 'README-bin', 'README' 
	}
	into kiekerPackagenamebase + "-" + kiekerVersion
}

def manualContent = project.copySpec {
	from ('kieker-documentation/userguide') {
		include 'kieker-userguide.pdf'
		rename 'kieker-userguide.pdf', "kieker-${kiekerVersion}_userguide.pdf"
	}
	into kiekerPackagenamebase + "-" + kiekerVersion + "/doc"
}

def exampleContent = project.copySpec {
	from ('kieker-examples') {
		include '**'
	}
  from ('examples') {
		include '**'
	}
  exclude '**/JavaEEServletContainerExample/build.xml'
  exclude '**/livedemo-source/**'
  exclude '**/.gradle/**'
  exclude '**/build/**'
  
	from ('kieker-monitoring/src-resources/META-INF') {
		include 'kieker.monitoring.default.properties'	
		rename 'kieker.monitoring.default.properties', 'kieker.monitoring.example.properties'
	}
	into kiekerPackagenamebase + "-" + kiekerVersion + "/examples"
}

def exampleJavaEEContent = project.copySpec {
	from ('kieker-monitoring/src-resources/META-INF') {
		include 'kieker.monitoring.default.properties'	
		rename 'kieker.monitoring.default.properties', 'kieker.monitoring.properties'
	}
	into kiekerPackagenamebase + "-" + kiekerVersion + "/examples/JavaEEServletContainerExample/jetty"
}

task docs(type: Javadoc) {
    source subprojects.collect {project -> project.sourceSets.main.allJava } 
    classpath = files(subprojects.collect {project -> project.sourceSets.main.compileClasspath}) 
    destinationDir = new File(projectDir, 'javadoc')
}

task prepareExamplesForDistribution(dependsOn: ['kieker-examples:buildStandaloneExamples' ]) << {
}

task distributeBinaryZip(type: Zip, group: 'distribution', description: 'Distributes binary archive.', dependsOn: [mainJar, emfJar, aspectJJar, docs, 'kieker-documentation:userguide:buildDocumentation', prepareExamplesForDistribution]) {
	classifier = 'binaries'
	destinationDir = file('dist/releases')
	with binaryContent, manualContent, exampleContent, exampleJavaEEContent
}

task distributeBinaryTar(type: Tar, group: 'distribution', description: 'Distributes binary archive.', dependsOn: [mainJar, emfJar, aspectJJar, docs, 'kieker-documentation:userguide:buildDocumentation', prepareExamplesForDistribution]) {
	classifier = 'binaries'
	destinationDir = file('dist/releases')
	with binaryContent, manualContent, exampleContent, exampleJavaEEContent
	
	compression = Compression.GZIP 
	extension = 'tar.gz'
}

def sourceContent = project.copySpec {
	from (projectDir) {
		include '*'
		include 'bin/**'
		include 'src/**'
		include 'lib/**'
    
    exclude '**/.gradle/**'
	}
	into kiekerPackagenamebase + "-" + kiekerVersion
}

task checkReleaseArchives(type: Exec, dependsOn: [distribute]) {
	commandLine 'bin/dev/check-release-archives.sh'
}

task distributeSourceZip(type: Zip, group: 'distribution', dependsOn: [mainJar, emfJar, aspectJJar]) {
	description = 'Distributes source archive.'
	destinationDir = file('dist/releases')
	classifier = 'sources'
	with sourceContent
}

task distributeSourceTar(type: Tar, group: 'distribution', dependsOn: [mainJar, emfJar, aspectJJar]) {
	description = 'Distributes source archive.'
	destinationDir = file('dist/releases')
	classifier = 'sources'
	with sourceContent
	
	compression = Compression.GZIP 
	extension = 'tar.gz'
}

task startRServe() << {
	'bin/dev/rserve-control.sh start'.execute()
}
distribute.mustRunAfter startRServe

task stopRServe(type: Exec) {
	commandLine 'bin/dev/rserve-control.sh', 'stop'
	
	ignoreExitValue = true
}
startRServe.finalizedBy stopRServe
stopRServe.mustRunAfter distribute

task enableRTests() << {
	tasks.withType(Test) {
		systemProperties['TestKiekerRTests'] = 'true'
	}
}
distribute.mustRunAfter enableRTests

task jenkinsBuild(dependsOn: [mainJar, emfJar, aspectJJar]) {
	description = 'Builds and tests the JAR files of the Kieker Framework'
}

task jenkinsNightlyBuild(dependsOn: [startRServe, enableRTests, distribute, checkReleaseArchives]) {
	description = 'Builds and tests the release of the Kieker Framework'
}
