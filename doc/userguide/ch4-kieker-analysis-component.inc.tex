%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Kieker Analysis Component
% 
% $Date$
% $Rev$:
% $Author$

\chapter{\KiekerAnalysisPart{} Component}\label{chap:componentsAnalysis}

\NOTIFYBOX{The Java sources of this chapter, as well as a pre-compiled binary, %
can be found in the %
\file{\customComponentsBookstoreApplicationDirDistro{}/} directory of the %
binary release.}

\section{Pipe-and-Filter Framework and Included Plugins}\label{sec:analysis:controller}

An analysis with \KiekerAnalysisPart{} is set up and executed employing %
the class \class{AnalysisController}. %
\KiekerAnalysisPart{} provides a framework to define and execute pipe-and-filter %
architectures of analysis plugins, i.e., monitoring readers and analysis filters, %
as well as repositories. %
This section describes how to use and develop readers, filters, and % 
repositories. The description is based on the example %
pipe-and-filter architecture shown in Figure~\ref{fig:example:pipe-and-filter}. The custom monitoring reader %
\class{MyPipeReader}, which corresponds to the writer developed in Section~\ref{sec:monitoring-log-writers}, %
sends records to the connected custom filter \class{MyResponseTimeFilter}. %
This filter accepts only events of the record type \class{MyResponseTimeRecord}, 
developed in Section~\ref{sec:componentsMonitoring:monitoringRecords}. %
The \class{MyResponseTimeFilter} classifies incoming \class{MyResponseTimeRecord}s %
based on whether they satisfy or exceed a configured threshold and passes them %
to the respective output ports, \method{validResponseTimes} or \method{invalidResponseTimes}. %
Two instances of a second custom filter, \class{MyResponseTimeOutputPrinter}, %
print the received records to the standard output stream.

\begin{figure}
\includegraphics[width=\textwidth]{images/example-pipe-and-filter}
\caption{Example pipe-and-filter configuration}
\label{fig:example:pipe-and-filter}
\end{figure}

%  requires a monitoring reader %
% (Section~\ref{sec:analysis:reader}) and at least %
% one monitoring record consumer plugin (Section~\ref{sec:analysis:consumer}). %
% In addition to the monitoring record consumer plugin, %
% other analysis plugins can be registered. %

\begin{figure}\centering
\includegraphics[width=0.95\textwidth]{images/kieker_AnalysisControlleruserguide-modified}
\caption{Class diagram showing important \KiekerAnalysisPart{} classes and their relationship}
\label{fig:analysisController:classdiagram}
\end{figure}

\pagebreak

\noindent Figure~\ref{fig:analysisController:classdiagram} shows the class diagram %
with the important \KiekerAnalysisPart{} classes and their relationships. %
Setting up and running an analysis with \KiekerAnalysisPart{} requires the %
following steps to be performed, as sketched in Section~\ref{sec:example:analysis} already:

\medskip

\begin{compactenum}
\item Creating an instance of the \class{AnalysisController} class
\item Creating and registering monitoring readers (\method{registerReader}), 
filters (\method{registerFilter}), and repositories (\method{registerRepository}).
\item Connecting plugins to other plugins and to repositories (\method{connect})
\item Starting the analysis instance (\method{run}).
\end{compactenum}

\medskip

\noindent On invocation of the \method{run} method, the \class{Analysis Controller} %
calls the \method{init} method of all filter plugins allowing them to initialize. %
Then, it starts the configured monitoring readers by calling its \method{read} %
method. Plugins send data via their output ports to connected input ports of other 
plugins. Being the sink of a pipe-and-filter architecture, readers don't have %
input ports. As soon as the reader returns from the execution of its \method{read} 
method, the method \method{terminate} of each registered plugin is called by the %
\class{Analysis Controller}. \KiekerAnalysisPart{} configurations can be saved %
to a \class{.kax} file by calling the \class{Analysis Controller}'s \method{saveToFile} method. %
The \class{Analysis Controller} provides a constructor which accepts the %
file system location of a \class{.kax} file to load the configuration from. %
 %
In order to support the asynchronous execution of the \class{AnalysisController} instance, %
we provide the \class{AnalysisControllerThread} class.

\subsection{Programmatic Creation of Pipe-and-Filter Architectures}\label{sec:analysis:programmaticCreation}

To give a first impression of the programmatic %
instantiation, configuration, and connection of plugins, Listing~\ref{listing:StarterInitConnect} %
demonstrates this procedure for the example, using \class{MyPipeReader} and %
\class{MyResponseTimeFilter}, according to Figure~\ref{fig:example:pipe-and-filter}.

The configuration for the \class{MyPipeReader} is created in lines~54 and~55. %
Using this configuration, the reader is created in line~56, and registered to %
the \class{AnalysisController} in line~57. Similarly, lines~60--66 initialize %
and register the \class{MyResponseTimeFilter}. The reader's output is connected %
to the filter's input in line~67. % 
The entire programmatic creation of the pipe-and-filter architecture shown %
in Figure~\ref{fig:example:pipe-and-filter}, can be found in the example  %
file \file{Starter.java}.

\medskip

\setJavaCodeListing
\lstinputlisting[caption=Initializing and connecting the example reader and filter (Starter.java),label=listing:StarterInitConnect,firstline=53, lastline=68, firstnumber=53]%
{\customComponentsBookstoreApplicationDir/src/kieker/examples/userguide/ch3and4bookstore/Starter.java}


\subsection{Monitoring Reader Plugins}

% Warning-tag for the reader-writer-thing
The monitoring readers are the direct counterpart to the monitoring %
writers. While writers receive records and write them into files or other kinds %
of monitoring logs/streams, readers deserialize monitoring data and provide it as %
\class{IMonitoringRecord} instances. 

\begin{figure}[h]\centering
\includegraphics[scale=0.7]{images/kieker_readerimplsuserguide-modified}
\caption{Interface \class{IMonitoringReader} and implementing classes}
\label{Figure:ReaderHierarchy}
\end{figure}

% \pagebreak

% \
% 
% \WARNBOX{This means that whenever a new writer is implemented, a corresponding reader has to be implemented as well. If one want for example to store the recorded informations in a database, one should be capable of reading these saved informations from the database again.}
% 
% \

% \enlargethispage{1cm}

\noindent There are already some readers implemented in \Kieker,  as shown in the %
class diagram in Figure \ref{Figure:ReaderHierarchy}. %
The \class{FSReader} has already been used in Section~\ref{sec:example:analysis}. %
The \class{FSReaderRealtime} can be used to simulate continuous monitoring of a %
production system. It adds delays between the delivery of the monitoring records %
to its consumers according to the original delays reconstructed from the logging %
timestamps (Section~\ref{sec:componentsMonitoring:monitoringRecords}).
A brief description of how to use the \class{JMSReader} can be found in Appendix~%
\ref{appendix:usingJMS}. Please note that the database reader (\class{JMSReader}) %
is currently in a prototype stage and that they should be used with care. %
Like each plugin, readers are configured via properties, as used in Section~%
\ref{sec:analysis:programmaticCreation} and detailed in Section~%
\ref{sec:analysis:configuration}. 

\subsection{Filter Plugins}

Filter plugins receive events (Java objects) via input ports from other %
plugins and implement analyses or visualizations based on these events. %
Consumer plugins must extend the class \class{AbstractFilterPlugin} %
(see Figure~\ref{fig:analysisController:classdiagram}). %

\Kieker{} already includes some basic filter plugins. For example, the %
\class{CountingFilter} and  \class{TeeFilter} forward incoming events %
to their output ports. The \class{CountingFilter} additionally provides the %
current number of received records via a second output port. The \class{TeeFilter} %
prints additionally prints incoming events to an output stream, which may be %
the standard output, standard error, a logger, or a file. %
A \class{TimestampFilter} and a \class{TypeFilter} filters incoming records by %
timestamp and by type, respectively. A \class{TraceIdFilter} filters incoming %
trace events (e.g., \class{OperationExecutionRecord}s, see Section~%
\ref{chap:example}) by trace id. Like each plugin, filters are configured %
via properties, as used in Section~\ref{sec:analysis:programmaticCreation} and %
detailed in Section~%
\ref{sec:analysis:configuration}. %

% \pagebreak
% \setJavaCodeListing
%\lstinputlisting[caption=MyReponseTimeConsumer.java,label=lst:MyReponseTimeConsumer,firstline=21,firstnumber=21]{\customComponentsBookstoreApplicationDir/src/kieker/examples/userguide/ch3and4bookstore/MyResponseTimeConsumer.java}

% The following Listing~\ref{listing:AnalysisController} shows how to create and run an analysis %
% with these custom components:
% 
% \setJavaCodeListing
% \lstinputlisting[caption=Code snippet setting up and running a \KiekerAnalysisPart{} instance (Starter.java),label=listing:AnalysisController,firstline=48, lastline=82, firstnumber=48]%
% {\customComponentsBookstoreApplicationDir/src/kieker/examples/userguide/ch3and4bookstore/Starter.java}

% \enlargethispage{1.2cm}

\section{Developing Analysis Plugins and Repositories}\label{sec:analysis:plugins}

When implementing analysis plugins (i.e., readers or filters) and repositories, %
the classes \class{AbstractReaderPlugin}, \class{AbstractFilterPlugin}, or, %
respectively, \class{AbstractRepository} need to be extended %
(Figure~\ref{fig:analysisController:classdiagram}). %
Section~\ref{sec:analysis:configuration} describes how plugins and repositories %
can be configured via properties. %
Section~\ref{sec:analysis:pluginAnnotation} %
describes how to declare meta-information for plugins using %
dedicated class and method annotations. %
Specific information on the development of custom filters, readers, and repositories %
are given in Sections~\ref{sec:analysis:filters}--\ref{sec:analysis:repositories}. %

% The monitoring record consumer plugins described in the following %
% Section~\ref{sec:analysis:consumer}, are special analysis plugins that receive %
% the monitoring records provided by the monitoring reader. %
% Starting with these monitoring record plugins, analysis plugins can be connected %
% in a pipe-and-filter style to implement more complex analyses. %
% \Kieker{} provides input and output port interfaces and implementing classes %
% to implement such analyses. See the documentation of the classes \class{AbstractInputPort} %
% and \class{OutputPort} for details. \KiekerTraceAnalysis{} is implemented %
% based on this pattern. 

\subsection{Configuration}\label{sec:analysis:configuration}

\noindent According to the %
configuration of the \KiekerMonitoringPart{} components (see Section~\ref{sec:monitoring:configuration}), 
filters are configured via \class{Configuration} objects. Filters must %
provide a public constructor, accepting a \class{Configuration} object as %
its only argument. It is important to invoke the constructor of the super class. %
The configuration properties accepted by a plugin should be provided via \class{public static} %
constants with prefix \method{CONFIG\_PROPERTY\_NAME\_} in order to ease the %
programmatic initialization of plugins. For the example filter \class{MyResponseTimeFilter},
Listing~\ref{listing:MyResponseTimeFilterConstructor} shows the constructor, 
the configuration property and the corresponding member value obtained from the configuration.

\setJavaCodeListing
\lstinputlisting[firstline=45, firstnumber=45, lastline=53, caption={Plugin constructor with Configuration}, label=listing:MyResponseTimeFilterConstructor]%
{\customComponentsBookstoreApplicationDir/src/kieker/examples/userguide/ch3and4bookstore/MyResponseTimeFilter.java}

\noindent Additionally, filters must provide a default configuration and the %
current configuration via the methods \method{getDefaultConfiguration} and %
\method{getCurrentConfiguration}. Please note that the returned configuration %
must be sufficient to initialize the filter via the mentioned constructor. %
The \class{AnalysisController} uses the \method{getCurrentConfiguration} to %
save the pipe-and-filter configuration. Listing~\ref{listing:MyResponseTimeFilterEventsToOutput} %
shows how the methods are implemented for the example filter \class{MyResponseTimeFilter}. %

\setJavaCodeListing
\lstinputlisting[firstline=72, firstnumber=72, lastline=84, caption={Plugin returning its default and current configuration}, label=listing:MyResponseTimeFilterEventsToOutput]%
{\customComponentsBookstoreApplicationDir/src/kieker/examples/userguide/ch3and4bookstore/MyResponseTimeFilter.java}


\subsection{@Plugin Annotation and Output Ports}\label{sec:analysis:pluginAnnotation}

\noindent The \class{@Plugin} class annotation is used to define a %
plugin name, a description, and the list of output ports. %
Listing~\ref{listing:MyResponseTimeFilterPluginAnnotationOutputs} shows the %
\class{@Plugin} annotation for the example filter.

If the \class{@Plugin} annotation is not present for a plugin, the \method{name} %
defaults to the plugin's (simple) classname, the \method{description} defaults %
to the empty string, and the list of output ports is empty. These default values %
are also used in case a respective attribute is omitted. %
Note that the name is not required to be a unique among filters; it is simply %
used for descriptive purposes, such as in Figure~\ref{fig:example:pipe-and-filter}. %

Output ports are specified using the nested \class{@OutputPort} annotation. %
In addition to a name and a description for the output port, a list of event %
types can be specified. Note that in this case, the name is mandatory and must %
be unique for a plugin, as it is used for connecting input and output ports. %
The list of event types defaults to a list including only \class{Object.class}. %
The output port names should be provided as a \class{public static} constant %
with prefix \method{OUTPUT\_PORT\_NAME\_}, in order to ease the programmatic connection of %
pipe-and-filter, as previously shown in Listing~\ref{lst:BookstoreAnalysisStarter}.

\setJavaCodeListing
\lstinputlisting[firstline=31, firstnumber=31, lastline=44, caption={@Plugin annotation for the example plugin \class{MyResponseTimeFilter}}, label=listing:MyResponseTimeFilterPluginAnnotationOutputs]%
{\customComponentsBookstoreApplicationDir/src/kieker/examples/userguide/ch3and4bookstore/MyResponseTimeFilter.java}

\noindent Plugins can send events to their output ports by the \method{deliver} method %
provided by the super class. The method expects the output port name and %
the event to be sent as arguments. Listing~\ref{listing:MyResponseTimeFilterPluginAnnotationOutputs} %
shows how the example filter plugin \class{MyResponseTimeFilter} delivers records %
to its two output ports declared in the \class{@Plugin} annotation.

\setJavaCodeListing
\lstinputlisting[firstline=61, firstnumber=61, lastline=67, caption={Plugin sending events to output ports}, label=listing:MyResponseTimeFilterPluginAnnotationOutputs]%
{\customComponentsBookstoreApplicationDir/src/kieker/examples/userguide/ch3and4bookstore/MyResponseTimeFilter.java}


\subsection{Developing Monitoring Reader Plugins}\label{sec:analysis:reader}

\noindent The implementation of a custom reader is similar to the implementation of a %
monitoring writer. Custom readers should extend the class \class{AbstractKiekerMonitoringReader} %
which already provides an implementation of the observer pattern. %
By invoking the method \method{deliverRecord},  the delivery of records is then %
delegated to the super class.

Listing~\ref{listing:MyPipeReaderPluginAnnotation} shows the \class{@Plugin} annotation %
(Section~\ref{sec:analysis:pluginAnnotation}) of the example reader %
\class{MyPipeReader}. Reading monitoring records from the monitoring % 
pipe introduced in the previous Chapter~\ref{sec:monitoring-log-writers}, %
the reader provides received monitoring records via its output port.

% If there is nothing on the pipe to be read, the reader waits 4 seconds at maximum before it terminates.
% \setJavaCodeListing
% \lstinputlisting[firstline=29, firstnumber=29, caption=MyPipeReader.java (excerpt), label=listing:MyReader,float]{\customComponentsBookstoreApplicationDir/src/kieker/examples/userguide/ch3and4bookstore/MyPipeReader.java}

\TODO{Change output event type to \class{IMonitoringRecord}}.

\setJavaCodeListing
\lstinputlisting[firstline=30, firstnumber=30, lastline=38, caption={@Plugin annotation for the example reader}, label=listing:MyPipeReaderPluginAnnotation]%
{\customComponentsBookstoreApplicationDir/src/kieker/examples/userguide/ch3and4bookstore/MyPipeReader.java}

\noindent Listing~\ref{listing:MyPipeReaderInit} shows the \class{MyPipeReader}'s %
\method{init} method. In this case, the reader reads the pipe name from the %
configuration and connects to the named pipe. 

\setJavaCodeListing
\lstinputlisting[firstline=56, firstnumber=56, lastline=64, caption={Example reader's initialization method}, label=listing:MyPipeReaderInit]%
{\customComponentsBookstoreApplicationDir/src/kieker/examples/userguide/ch3and4bookstore/MyPipeReader.java}

\noindent Listing~\ref{listing:MyPipeReaderRead} shows the \class{MyPipeReader}'s %
\method{read} method. In this case, the reader polls the pipe for new records %
and forwards these to its output port. 

\setJavaCodeListing
\lstinputlisting[firstline=66, firstnumber=66, lastline=84, caption={Example reader's \method{read} method}, label=listing:MyPipeReaderRead]%
{\customComponentsBookstoreApplicationDir/src/kieker/examples/userguide/ch3and4bookstore/MyPipeReader.java}

\TODO{\method{terminate}}

\subsection{Developing Filter Plugins}\label{sec:analysis:filters}

\setJavaCodeListing
\lstinputlisting[firstline=57, firstnumber=57, lastline=61, caption={@InputPort annotation for the example plugin's input method}, label=listing:MyResponseTimeFilterEventsToOutput]%
{\customComponentsBookstoreApplicationDir/src/kieker/examples/userguide/ch3and4bookstore/MyResponseTimeFilter.java}

\subsection{Developing Repositories}\label{sec:analysis:repositories}

\setJavaCodeListing
\lstinputlisting[firstline=57, firstnumber=57, lastline=61, caption={@Respository annotation for Kieker's system model repository}, label=listing:RepositoryAnnotation]%
{../../src/tools/kieker/tools/traceAnalysis/systemModel/repository/SystemModelRepository.java}

\setJavaCodeListing
\lstinputlisting[firstline=44, firstnumber=44, lastline=48, caption={Declaration of required repositories in the @Respository annotation}, label=listing:RepositoryRequirementDeclaration]%
{../../src/tools/kieker/tools/traceAnalysis/filter/AbstractTraceAnalysisFilter.java}

\setJavaCodeListing
\lstinputlisting[firstline=135, firstnumber=135, lastline=135, caption={Accessing a repository within in a plugin}, label=listing:RepositoryAccess]%
{../../src/tools/kieker/tools/traceAnalysis/filter/AbstractTraceAnalysisFilter.java}

